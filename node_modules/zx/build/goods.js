// src/goods.ts
import assert from "node:assert";
import { createInterface } from "node:readline";
import { $, within, ProcessOutput } from "./core.js";
import { isString, parseDuration } from "./util.js";
import {
  chalk,
  minimist,
  nodeFetch
} from "./vendor.js";
import { default as default2 } from "node:path";
import * as os from "node:os";
var argv = minimist(process.argv.slice(2));
function updateArgv(args) {
  argv = minimist(args);
  global.argv = argv;
}
function sleep(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, parseDuration(duration));
  });
}
async function fetch(url, init) {
  $.log({ kind: "fetch", url, init });
  return nodeFetch(url, init);
}
function echo(pieces, ...args) {
  let msg;
  const lastIdx = pieces.length - 1;
  if (Array.isArray(pieces) && pieces.every(isString) && lastIdx === args.length) {
    msg = args.map((a, i) => pieces[i] + stringify(a)).join("") + pieces[lastIdx];
  } else {
    msg = [pieces, ...args].map(stringify).join(" ");
  }
  console.log(msg);
}
function stringify(arg) {
  if (arg instanceof ProcessOutput) {
    return arg.toString().replace(/\n$/, "");
  }
  return `${arg}`;
}
async function question(query, options) {
  let completer = void 0;
  if (options && Array.isArray(options.choices)) {
    completer = function completer2(line) {
      const completions = options.choices;
      const hits = completions.filter((c) => c.startsWith(line));
      return [hits.length ? hits : completions, line];
    };
  }
  const rl = createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: true,
    completer
  });
  return new Promise(
    (resolve) => rl.question(query ?? "", (answer) => {
      rl.close();
      resolve(answer);
    })
  );
}
async function stdin() {
  let buf = "";
  process.stdin.setEncoding("utf8");
  for await (const chunk of process.stdin) {
    buf += chunk;
  }
  return buf;
}
async function retry(count, a, b) {
  const total = count;
  let callback;
  let delayStatic = 0;
  let delayGen;
  if (typeof a == "function") {
    callback = a;
  } else {
    if (typeof a == "object") {
      delayGen = a;
    } else {
      delayStatic = parseDuration(a);
    }
    assert(b);
    callback = b;
  }
  let lastErr;
  let attempt = 0;
  while (count-- > 0) {
    attempt++;
    try {
      return await callback();
    } catch (err) {
      let delay = 0;
      if (delayStatic > 0)
        delay = delayStatic;
      if (delayGen)
        delay = delayGen.next().value;
      $.log({
        kind: "retry",
        error: chalk.bgRed.white(" FAIL ") + ` Attempt: ${attempt}${total == Infinity ? "" : `/${total}`}` + (delay > 0 ? `; next in ${delay}ms` : "")
      });
      lastErr = err;
      if (count == 0)
        break;
      if (delay)
        await sleep(delay);
    }
  }
  throw lastErr;
}
function* expBackoff(max = "60s", rand = "100ms") {
  const maxMs = parseDuration(max);
  const randMs = parseDuration(rand);
  let n = 1;
  while (true) {
    const ms = Math.floor(Math.random() * randMs);
    yield Math.min(2 ** n++, maxMs) + ms;
  }
}
async function spinner(title, callback) {
  if (typeof title == "function") {
    callback = title;
    title = "";
  }
  let i = 0;
  const spin = () => process.stderr.write(`  ${"\u280B\u2819\u2839\u2838\u283C\u2834\u2826\u2827\u2807\u280F"[i++ % 10]} ${title}\r`);
  return within(async () => {
    $.verbose = false;
    const id = setInterval(spin, 100);
    let result;
    try {
      result = await callback();
    } finally {
      clearInterval(id);
      process.stderr.write(" ".repeat((process.stdout.columns || 1) - 1) + "\r");
    }
    return result;
  });
}
export {
  argv,
  echo,
  expBackoff,
  fetch,
  os,
  default2 as path,
  question,
  retry,
  sleep,
  spinner,
  stdin,
  updateArgv
};
